// main.js - Electron Main Process (Aura Gaming PC Optimizer - FIXED) const { app, BrowserWindow, ipcMain, dialog, shell } = require('electron'); const path = require('path'); const os = require('os'); const fs = require('fs').promises; const fsSync = require('fs'); const { exec } = require('child_process'); const { promisify } = require('util'); const execAsync = promisify(exec); // System info const si = require('systeminformation'); // ---------------- Firebase (CommonJS v8) ---------------- const firebase = require('firebase/app'); require('firebase/firestore'); let FB = null; async function ensureFirebase() { if (FB) return FB; const firebaseConfig = { apiKey: "AIzaSyCx62ICCDFVoskUgyHdo3r8XZYECASDgQ4", authDomain: "aura-opt-admin.firebaseapp.com", projectId: "aura-opt-admin", storageBucket: "aura-opt-admin.firebasestorage.app", messagingSenderId: "622881381421", appId: "1:622881381421:web:8807807c058754fc062ca4" }; if (!firebase.apps.length) { firebase.initializeApp(firebaseConfig); } FB = { db: firebase.firestore(), doc: (db, collection, id) => db.collection(collection).doc(id), getDoc: async (ref) => { const snap = await ref.get(); return { exists: () => snap.exists, data: () => snap.data() }; }, setDoc: async (ref, data, options) => ref.set(data, options), collection: (db, name) => db.collection(name), query: (collectionRef, ...queries) => { let q = collectionRef; queries.forEach(constraint => { q = constraint(q); }); return q; }, where: (field, op, value) => (query) => query.where(field, op, value), getDocs: async (query) => { const snap = await query.get(); return { empty: snap.empty, docs: snap.docs }; }, updateDoc: async (ref, data) => ref.update(data) }; return FB; } // ------------------------------------------------------------ // Paths let SETTINGS_PATH = null; let LOG_PATH = null; let DEBUG_LOG_PATH = null; let REPORT_PATH = null; let RESTORE_POINTS_PATH = null; // App State const appState = { window: null, isActivated: false, isOptimizerEnabled: true, debugMode: false, hwid: null, lastOptimization: null, lastRamFreedGB: 0, lastJunkCleanedGB: 0, options: { gameMode: true, backgroundProcessTrim: true, diskCleanup: true, browserCacheCleanup: true, recycleBinEmpty: true, windowsUpdateCacheCleanup: false, logsCleanup: true, memoryCompression: false, storageOptimize: true, dnsSwitch: false, tcpTune: false, gpuVisualTuning: true, hardwareGpuScheduling: false, nvapi: false, startupItems: false } }; // Admin check cache let isAdminCached = null; // Helpers function isWindows() { return process.platform === 'win32'; } function bytesToGB(bytes) { return Math.max(0, (bytes || 0) / (1024 ** 3)); } function ensurePaths() { if (!SETTINGS_PATH) { const userData = app.getPath('userData'); SETTINGS_PATH = path.join(userData, 'aura_settings.json'); LOG_PATH = path.join(userData, 'aura.log'); DEBUG_LOG_PATH = path.join(userData, 'debug.log'); REPORT_PATH = path.join(userData, 'optimization_report.json'); RESTORE_POINTS_PATH = path.join(userData, 'restore_points.json'); } } function sendToRenderer(channel, payload) { if (appState.window && !appState.window.isDestroyed()) { appState.window.webContents.send(channel, payload); } } function logLine(message, isDebug = false) { try { ensurePaths(); const timestamp = new Date().toISOString(); const line = [${timestamp}] ${message}\n; const targetPath = isDebug ? DEBUG_LOG_PATH : LOG_PATH; fsSync.appendFileSync(targetPath, line); } catch (error) { console.error('Logging error:', error); } } // Admin check helper async function checkIfAdmin() { if (isAdminCached !== null) return isAdminCached; if (!isWindows()) { isAdminCached = false; return false; } try { await execAsync('net session', { windowsHide: true, timeout: 3000 }); isAdminCached = true; return true; } catch { isAdminCached = false; return false; } } // Safe exec with PowerShell bypass async function safeExec(command, options = {}) { if (!isWindows()) return { ok: false, error: 'Windows-only operation' }; // Bypass execution policy for PowerShell commands let finalCommand = command; if (command.toLowerCase().includes('powershell')) { if (!command.includes('-ExecutionPolicy')) { finalCommand = command.replace( /PowerShell\.exe/i, 'PowerShell.exe -ExecutionPolicy Bypass' ); } } try { const { stdout, stderr } = await execAsync(finalCommand, { windowsHide: true, timeout: 30000, ...options }); return { ok: true, stdout: stdout || '', stderr: stderr || '' }; } catch (error) { logLine(Command failed: ${finalCommand} - ${error.message}, true); return { ok: false, error: error.message, stdout: error.stdout || '', stderr: error.stderr || '' }; } } async function loadSettings() { ensurePaths(); try { const data = await fs.readFile(SETTINGS_PATH, 'utf-8'); const settings = JSON.parse(data); if (settings.options) appState.options = { ...appState.options, ...settings.options }; if (typeof settings.isOptimizerEnabled === 'boolean') appState.isOptimizerEnabled = settings.isOptimizerEnabled; if (typeof settings.debugMode === 'boolean') appState.debugMode = settings.debugMode; if (settings.lastOptimization) appState.lastOptimization = settings.lastOptimization; if (typeof settings.lastRamFreedGB === 'number') appState.lastRamFreedGB = settings.lastRamFreedGB; if (typeof settings.lastJunkCleanedGB === 'number') appState.lastJunkCleanedGB = settings.lastJunkCleanedGB; } catch { logLine('First run - creating default settings'); } } async function saveSettings() { ensurePaths(); const settings = { options: appState.options, isOptimizerEnabled: appState.isOptimizerEnabled, debugMode: appState.debugMode, lastOptimization: appState.lastOptimization, lastRamFreedGB: appState.lastRamFreedGB, lastJunkCleanedGB: appState.lastJunkCleanedGB }; try { await fs.writeFile(SETTINGS_PATH, JSON.stringify(settings, null, 2)); } catch (error) { logLine(Failed to save settings: ${error.message}); } } // HWID async function getStableHWID() { if (appState.hwid) return appState.hwid; try { const baseboard = await si.baseboard(); const system = await si.system(); const cpu = await si.cpu(); const components = [ baseboard.serial || 'unknown', system.uuid || 'unknown', cpu.brand || 'unknown', os.hostname(), os.userInfo().username ]; const combined = components.join('|'); const crypto = require('crypto'); const hash = crypto.createHash('sha256').update(combined).digest('hex'); appState.hwid = hash.substring(0, 32).toUpperCase(); return appState.hwid; } catch (error) { logLine(HWID generation error: ${error.message}); const fallback = ${os.hostname()}_${os.userInfo().username}; const crypto = require('crypto'); const hash = crypto.createHash('sha256').update(fallback).digest('hex'); appState.hwid = hash.substring(0, 32).toUpperCase(); return appState.hwid; } } // Window async function createWindow() { appState.window = new BrowserWindow({ width: 1200, height: 800, minWidth: 1000, minHeight: 700, frame: false, resizable: true, backgroundColor: '#0f0f0f', webPreferences: { preload: path.join(__dirname, 'preload.js'), contextIsolation: true, nodeIntegration: false, sandbox: false }, show: true }); await appState.window.loadFile(path.join(__dirname, 'index.html')); appState.window.once('ready-to-show', () => { appState.window.show(); }); if (appState.debugMode) { appState.window.webContents.openDevTools(); } } // License IPC ipcMain.handle('get-hwid', async () => { try { const hwid = await getStableHWID(); return { ok: true, hwid }; } catch (error) { return { ok: false, error: error.message }; } }); ipcMain.handle('activate-license', async (_e, { key, hwid }) => { try { const f = await ensureFirebase(); logLine(License activation attempt for key: ${String(key).substring(0, 8)}...); const docRef = f.doc(f.db, 'license_keys', key); const snap = await f.getDoc(docRef); if (!snap.exists()) { sendToRenderer('optimization-complete', { ok: false, error: 'Invalid license key' }); return { ok: false, error: 'Invalid license key' }; } const data = snap.data(); if (data.isUsed && data.usedByHwid && data.usedByHwid !== hwid) { const msg = 'License key is already in use on another device'; sendToRenderer('optimization-complete', { ok: false, error: msg }); return { ok: false, error: msg }; } await f.setDoc(docRef, { ...data, isUsed: true, usedByHwid: hwid, activatedAt: new Date().toISOString() }, { merge: true }); appState.isActivated = true; await saveSettings(); logLine('License activated successfully'); return { ok: true }; } catch (error) { logLine(License activation failed: ${error.message}); sendToRenderer('optimization-complete', { ok: false, error: error.message }); return { ok: false, error: error.message }; } }); ipcMain.handle('logout', async () => { try { const f = await ensureFirebase(); const hwid = await getStableHWID(); const qy = f.query( f.collection(f.db, 'license_keys'), f.where('usedByHwid', '==', hwid), f.where('isUsed', '==', true) ); const qs = await f.getDocs(qy); for (const d of qs.docs) { await f.updateDoc(d.ref, { isUsed: false, usedByHwid: null }); } appState.isActivated = false; await saveSettings(); logLine('License deactivated successfully'); return { ok: true }; } catch (error) { logLine(License deactivation failed: ${error.message}); return { ok: false, error: error.message }; } }); // Auto-activation on startup async function checkActivationOnLaunch() { try { const f = await ensureFirebase(); const hwid = await getStableHWID(); const qy = f.query( f.collection(f.db, 'license_keys'), f.where('usedByHwid', '==', hwid), f.where('isUsed', '==', true) ); const qs = await f.getDocs(qy); appState.isActivated = !qs.empty; if (appState.isActivated) logLine('Auto-activation successful'); } catch (error) { logLine(Auto-activation check failed: ${error.message}); appState.isActivated = false; } } // System Stats with multi-language latency support ipcMain.handle('get-system-stats', async () => { try { const mem = await si.mem(); const graphics = await si.graphics(); const osInfo = await si.osInfo(); const cpu = await si.cpu(); let latencyMs = null; if (isWindows()) { try { const { stdout } = await execAsync('ping -n 1 8.8.8.8', { timeout: 5000, windowsHide: true }); // Multi-language support for latency parsing const patterns = [ /Average = (\d+)ms/i, // English /Moyenne\s?=\s?(\d+)\s?ms/i, // French /Mittelwert\s?=\s?(\d+)\s?ms/i, // German /Media\s?=\s?(\d+)\s?ms/i, // Spanish/Italian /平均\s?=\s?(\d+)\s?ms/i, // Chinese /time=(\d+)ms/i, // Fallback: parse first reply time /時間=(\d+)ms/i // Japanese ]; for (const pattern of patterns) { const match = stdout.match(pattern); if (match) { latencyMs = parseInt(match[1], 10); break; } } // Ultimate fallback: find any number followed by ms if (latencyMs === null) { const fallback = stdout.match(/(\d+)\s?ms/i); if (fallback) latencyMs = parseInt(fallback[1], 10); } } catch (error) { logLine(Latency check failed: ${error.message}, true); } } const gpuModel = graphics.controllers[0]?.model || 'Unknown GPU'; return { isActivated: appState.isActivated, isOptimizerEnabled: appState.isOptimizerEnabled, lastOptimization: appState.lastOptimization, totalRamGB: bytesToGB(mem.total).toFixed(2), usedRamGB: bytesToGB(mem.active || mem.used).toFixed(2), freeRamGB: bytesToGB(mem.available || (mem.total - mem.used)).toFixed(2), ramFreed: appState.lastRamFreedGB.toFixed(2), junkCleaned: appState.lastJunkCleanedGB.toFixed(2), latencyMs, gpuModel, osVersion: ${osInfo.distro} ${osInfo.release}, cpuModel: cpu.brand, appVersion: app.getVersion(), appMemoryUsage: { heapUsed: Math.round(process.memoryUsage().heapUsed / 1024 / 1024) } }; } catch (error) { logLine(Get system stats error: ${error.message}); return { error: error.message }; } }); // Options ipcMain.handle('get-options', async () => ({ ...appState.options })); ipcMain.handle('set-options', async (_e, newOptions) => { appState.options = { ...appState.options, ...newOptions }; await saveSettings(); return { ok: true, options: appState.options }; }); ipcMain.handle('toggle-optimizer', async (_e, enabled) => { appState.isOptimizerEnabled = !!enabled; await saveSettings(); return { ok: true, isEnabled: appState.isOptimizerEnabled }; }); ipcMain.handle('toggle-debug-mode', async (_e, enabled) => { appState.debugMode = !!enabled; await saveSettings(); if (appState.window && appState.debugMode) { appState.window.webContents.openDevTools({ mode: 'detach' }); } return { ok: true, debugMode: appState.debugMode }; }); // Window controls ipcMain.on('window-minimize', () => { const w = BrowserWindow.getFocusedWindow(); if (w) w.minimize(); }); ipcMain.on('window-maximize', () => { const w = BrowserWindow.getFocusedWindow(); if (w) w.isMaximized() ? w.unmaximize() : w.maximize(); }); ipcMain.on('window-close', () => { const w = BrowserWindow.getFocusedWindow(); if (w) w.close(); }); // FS helpers - Optimized version function calculateFolderSize(folderPath) { let totalSize = 0; const walk = (p) => { try { const stats = fsSync.statSync(p); if (stats.isFile()) totalSize += stats.size; else if (stats.isDirectory()) { for (const item of fsSync.readdirSync(p)) walk(path.join(p, item)); } } catch { /* ignore */ } }; try { walk(folderPath); } catch (e) { logLine(Folder size calc error: ${e.message}, true); } return totalSize; } async function deleteFolderContents(folderPath) { try { if (!fsSync.existsSync(folderPath)) return 0; let totalDeleted = 0; const items = await fs.readdir(folderPath); for (const item of items) { const itemPath = path.join(folderPath, item); try { const stat = await fs.stat(itemPath); const itemSize = stat.isDirectory() ? calculateFolderSize(itemPath) : stat.size; if (stat.isDirectory()) { await fs.rm(itemPath, { recursive: true, force: true }); } else { await fs.unlink(itemPath); } totalDeleted += itemSize; } catch (err) { logLine(Could not delete ${itemPath}: ${err.message}, true); } } return totalDeleted; } catch (error) { logLine(Delete folder contents error: ${error.message}, true); return 0; } } async function deleteFolderContentsWithRetry(folderPath, retries = 3) { for (let i = 0; i < retries; i++) { try { return await deleteFolderContents(folderPath); } catch (err) { if (i === retries - 1) { logLine(Failed to delete ${folderPath} after ${retries} attempts: ${err.message}, true); return 0; } await new Promise(resolve => setTimeout(resolve, 1000)); } } return 0; } // ==================== OPTIMIZATION FUNCTIONS ==================== async function enableGameMode() { if (!isWindows()) return { ok: false }; const commands = [ 'reg add "HKCU\\Software\\Microsoft\\GameBar" /v AutoGameModeEnabled /t REG_DWORD /d 1 /f', 'reg add "HKCU\\Software\\Microsoft\\GameBar" /v AllowAutoGameMode /t REG_DWORD /d 1 /f', 'reg add "HKCU\\System\\GameConfigStore" /v GameDVR_Enabled /t REG_DWORD /d 0 /f', 'reg add "HKLM\\SOFTWARE\\Microsoft\\PolicyManager\\default\\ApplicationManagement\\AllowGameDVR" /v value /t REG_DWORD /d 0 /f', 'reg add "HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\GameDVR" /v AppCaptureEnabled /t REG_DWORD /d 0 /f', 'reg add "HKCU\\System\\GameConfigStore" /v GameDVR_FSEBehaviorMode /t REG_DWORD /d 2 /f' ]; for (const cmd of commands) await safeExec(cmd); return { ok: true }; } async function killBackgroundProcesses() { if (!isWindows()) return { ok: false }; // Only kill safe background services const safeToKill = [ 'OneDrive.exe', 'MicrosoftEdgeUpdate.exe', 'GoogleUpdate.exe', 'AdobeARM.exe' ]; // Ask user confirmation for these (returned in response) const askBeforeKill = [ 'Teams.exe', 'steam.exe', 'EpicGamesLauncher.exe', 'Discord.exe', 'Spotify.exe' ]; let killedCount = 0; // Check what's running first const { stdout } = await safeExec('tasklist /FO CSV /NH'); const running = new Set( stdout.split('\n') .map(line => { const match = line.match(/"([^"]+)"/); return match ? match[1] : null; }) .filter(Boolean) ); // Kill safe processes for (const p of safeToKill) { if (running.has(p)) { const res = await safeExec(taskkill /IM "${p}" /F 2>nul); if (res.ok) { killedCount++; logLine(Killed safe process: ${p}, true); } } } // Return list of apps that need user confirmation const needConfirmation = askBeforeKill.filter(p => running.has(p)); return { ok: true, killedCount, needsConfirmation: needConfirmation }; } async function cleanTempFiles() { if (!isWindows()) return { ok: false, cleanedGB: 0 }; const tempPaths = [ process.env.TEMP, process.env.TMP, path.join(process.env.LOCALAPPDATA || '', 'Temp') ]; // Only add Windows\Temp if running as admin const isAdmin = await checkIfAdmin(); if (isAdmin) { tempPaths.push(path.join(process.env.WINDIR || 'C:\\Windows', 'Temp')); } let total = 0; for (const p of tempPaths.filter(Boolean)) { if (fsSync.existsSync(p)) { try { total += await deleteFolderContents(p); } catch (err) { logLine(Failed to clean ${p}: ${err.message}, true); } } } return { ok: true, cleanedGB: bytesToGB(total) }; } async function cleanBrowserCaches() { if (!isWindows()) return { ok: false, cleanedGB: 0 }; // First, check and optionally close browsers const browsers = { 'chrome.exe': 'Google Chrome', 'msedge.exe': 'Microsoft Edge', 'firefox.exe': 'Mozilla Firefox', 'brave.exe': 'Brave Browser' }; const { stdout } = await safeExec('tasklist /FO CSV /NH'); const runningBrowsers = []; for (const [proc, name] of Object.entries(browsers)) { if (stdout.toLowerCase().includes(proc.toLowerCase())) { runningBrowsers.push(name); } } if (runningBrowsers.length > 0) { logLine(Warning: Browsers are running: ${runningBrowsers.join(', ')}, true); sendToRenderer('browsers-running', { browsers: runningBrowsers }); return { ok: false, error: 'Browsers must be closed first', cleanedGB: 0 }; } const localAppData = process.env.LOCALAPPDATA || ''; const cachePaths = [ path.join(localAppData, 'Google', 'Chrome', 'User Data', 'Default', 'Cache'), path.join(localAppData, 'Google', 'Chrome', 'User Data', 'Default', 'Code Cache'), path.join(localAppData, 'Microsoft', 'Edge', 'User Data', 'Default', 'Cache'), path.join(localAppData, 'Mozilla', 'Firefox', 'Profiles'), path.join(localAppData, 'BraveSoftware', 'Brave-Browser', 'User Data', 'Default', 'Cache') ]; let total = 0; for (const p of cachePaths) { if (!fsSync.existsSync(p)) continue; if (p.includes('Firefox')) { try { const profiles = (await fs.readdir(p, { withFileTypes: true })) .filter(dirent => dirent.isDirectory()) .map(dirent => dirent.name); for (const prof of profiles) { const profileCachePath = path.join(p, prof, 'cache2'); if (fsSync.existsSync(profileCachePath)) { total += await deleteFolderContentsWithRetry(profileCachePath); } } } catch (e) { logLine(Firefox cache cleanup error: ${e.message}, true); } } else { total += await deleteFolderContentsWithRetry(p); } } return { ok: true, cleanedGB: bytesToGB(total) }; } async function emptyRecycleBin() { if (!isWindows()) return { ok: false }; const isAdmin = await checkIfAdmin(); if (!isAdmin) { return { ok: false, error: 'Requires administrator privileges' }; } try { const r = await safeExec( 'PowerShell.exe -ExecutionPolicy Bypass -Command "Clear-RecycleBin -Force -ErrorAction SilentlyContinue"', { timeout: 60000 } ); return { ok: r.ok }; } catch (err) { logLine(Recycle bin empty failed: ${err.message}, true); return { ok: false, error: err.message }; } } async function cleanWindowsUpdateCache() { if (!isWindows()) return { ok: false, cleanedGB: 0 }; const isAdmin = await checkIfAdmin(); if (!isAdmin) { return { ok: false, error: 'Requires administrator privileges', cleanedGB: 0 }; } const updateCachePath = path.join( process.env.WINDIR || 'C:\\Windows', 'SoftwareDistribution', 'Download' ); try { // Stop Windows Update service await safeExec('net stop wuauserv', { timeout: 10000 }); // Wait for service to stop await new Promise(resolve => setTimeout(resolve, 2000)); let total = 0; if (fsSync.existsSync(updateCachePath)) { total = await deleteFolderContents(updateCachePath); } // Restart Windows Update service await safeExec('net start wuauserv', { timeout: 10000 }); return { ok: true, cleanedGB: bytesToGB(total) }; } catch (err) { // Try to restart service even if cleanup failed await safeExec('net start wuauserv'); return { ok: false, error: err.message, cleanedGB: 0 }; } } async function cleanSystemLogs() { if (!isWindows()) return { ok: false, cleanedGB: 0 }; const isAdmin = await checkIfAdmin(); const logPaths = [ path.join(process.env.LOCALAPPDATA || '', 'CrashDumps') ]; // Only add these if admin if (isAdmin) { logPaths.push( path.join(process.env.WINDIR || 'C:\\Windows', 'Logs'), path.join(process.env.WINDIR || 'C:\\Windows', 'Minidump') ); } let total = 0; for (const p of logPaths.filter(Boolean)) { if (fsSync.existsSync(p)) { try { total += await deleteFolderContents(p); } catch (err) { logLine(Failed to clean logs at ${p}: ${err.message}, true); } } } return { ok: true, cleanedGB: bytesToGB(total) }; } async function optimizeMemory() { if (!isWindows()) return { ok: false }; const isAdmin = await checkIfAdmin(); if (!isAdmin) { return { ok: false, error: 'Requires administrator privileges' }; } // Check Windows version const osInfo = await si.osInfo(); const build = parseInt(osInfo.build || '0', 10); const commands = []; // Memory compression only on Windows 10 1607+ (build 14393+) if (build >= 14393) { commands.push( 'PowerShell.exe -ExecutionPolicy Bypass -Command "Enable-MMAgent -MemoryCompression -ErrorAction SilentlyContinue"' ); } // Force garbage collection (safe on all versions) commands.push('PowerShell.exe -Command "[System.GC]::Collect()"'); // Empty working sets commands.push('PowerShell.exe -Command "EmptyWorkingSets"'); for (const cmd of commands) { await safeExec(cmd, { timeout: 15000 }); } return { ok: true }; } async function optimizeStorage() { if (!isWindows()) return { ok: false }; const isAdmin = await checkIfAdmin(); if (!isAdmin) { return { ok: false, error: 'Requires administrator privileges' }; } try { // Check if C: is SSD or HDD const fsSize = await si.fsSize(); const driveC = fsSize.find(d => (d.mount || '').toUpperCase() === 'C:'); if (!driveC) { return { ok: false, error: 'Drive C: not found' }; } // Get disk type const { stdout } = await execAsync( 'PowerShell.exe -Command "Get-PhysicalDisk | Where-Object {$_.DeviceID -eq 0} | Select-Object MediaType | ConvertTo-Json"', { timeout: 10000, windowsHide: true } ); let isSSD = false; try { const diskInfo = JSON.parse(stdout); isSSD = diskInfo.MediaType === 'SSD' || diskInfo.MediaType === 3; } catch { // Fallback: assume SSD if unsure (safer) isSSD = true; } if (isSSD) { // For SSD: only TRIM await safeExec( 'PowerShell.exe -ExecutionPolicy Bypass -Command "Optimize-Volume -DriveLetter C -ReTrim -ErrorAction SilentlyContinue"', { timeout: 60000 } ); logLine('SSD detected - TRIM optimization applied', true); } else { // For HDD: defrag with analysis await safeExec( 'defrag C: /A /H /V', // Analyze first, high priority { timeout: 300000 } // 5 minutes max ); logLine('HDD detected - Defragmentation applied', true); } return { ok: true, isSSD }; } catch (err) { logLine(Storage optimization error: ${err.message}, true); return { ok: false, error: err.message }; } } async function optimizeDNS() { if (!isWindows()) return { ok: false }; const isAdmin = await checkIfAdmin(); if (!isAdmin) { return { ok: false, error: 'Requires administrator privileges' }; } try { // Flush DNS cache first (doesn't need interface names) await safeExec('ipconfig /flushdns'); // Get actual network interface names const { stdout } = await execAsync( 'PowerShell.exe -Command "Get-NetAdapter | Where-Object {$_.Status -eq \'Up\'} | Select-Object Name | ConvertTo-Json"', { timeout: 10000, windowsHide: true } ); let interfaces = []; try { const parsed = JSON.parse(stdout); interfaces = Array.isArray(parsed) ? parsed : [parsed]; } catch { logLine('Failed to parse network interfaces', true); return { ok: true }; // At least DNS flush worked } // Set Cloudflare (1.1.1.1) and Google (8.8.8.8) DNS for each active interface for (const iface of interfaces) { if (!iface.Name) continue; const cmd = PowerShell.exe -ExecutionPolicy Bypass -Command "Set-DnsClientServerAddress -InterfaceAlias '${iface.Name}' -ServerAddresses '1.1.1.1','8.8.8.8'"; await safeExec(cmd, { timeout: 10000 }); logLine(Set DNS for interface: ${iface.Name}, true); } return { ok: true, interfaceCount: interfaces.length }; } catch (err) { logLine(DNS optimization error: ${err.message}, true); return { ok: false, error: err.message }; } } async function optimizeTCP() { if (!isWindows()) return { ok: false }; const isAdmin = await checkIfAdmin(); if (!isAdmin) { return { ok: false, error: 'Requires administrator privileges' }; } const commands = [ 'netsh int tcp set global autotuninglevel=normal', 'netsh int tcp set global rss=enabled', 'netsh int tcp set global chimney=disabled', 'netsh int tcp set global ecncapability=disabled', 'netsh int tcp set global timestamps=disabled' // Reduce overhead ]; for (const cmd of commands) { const res = await safeExec(cmd); if (!res.ok) { logLine(TCP optimization command failed: ${cmd}, true); } } return { ok: true }; } async function optimizeVisualEffects() { if (!isWindows()) return { ok: false }; const commands = [ // Disable animations 'reg add "HKCU\\Control Panel\\Desktop\\WindowMetrics" /v MinAnimate /t REG_SZ /d 0 /f', // Disable transparency 'reg add "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize" /v EnableTransparency /t REG_DWORD /d 0 /f', // Visual effects for best performance 'reg add "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\VisualEffects" /v VisualFXSetting /t REG_DWORD /d 2 /f', // Disable taskbar animations 'reg add "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced" /v TaskbarAnimations /t REG_DWORD /d 0 /f', // Disable window shadows 'reg add "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced" /v ListviewShadow /t REG_DWORD /d 0 /f', // Show window contents while dragging (actually helpful) 'reg add "HKCU\\Control Panel\\Desktop" /v DragFullWindows /t REG_SZ /d 1 /f', // Set performance mode 'reg add "HKCU\\Software\\Microsoft\\Windows\\DWM" /v EnableAeroPeek /t REG_DWORD /d 0 /f' ]; for (const cmd of commands) await safeExec(cmd); // Refresh explorer to apply changes await safeExec('taskkill /F /IM explorer.exe && start explorer.exe'); return { ok: true }; } async function enableHardwareGPUScheduling() { if (!isWindows()) return { ok: false }; const isAdmin = await checkIfAdmin(); if (!isAdmin) { return { ok: false, error: 'Requires administrator privileges' }; } // Check Windows version (needs Windows 10 2004+, build 19041+) const osInfo = await si.osInfo(); const build = parseInt(osInfo.build || '0', 10); if (build < 19041) { return { ok: false, error: 'Hardware GPU Scheduling requires Windows 10 version 2004 or later' }; } // Check if GPU supports it const graphics = await si.graphics(); const hasCompatibleGPU = graphics.controllers.some(gpu => { const vendor = (gpu.vendor || '').toLowerCase(); return vendor.includes('nvidia') || vendor.includes('amd') || vendor.includes('intel'); }); if (!hasCompatibleGPU) { return { ok: false, error: 'No compatible GPU detected' }; } const result = await safeExec( 'reg add "HKLM\\SYSTEM\\CurrentControlSet\\Control\\GraphicsDrivers" /v HwSchMode /t REG_DWORD /d 2 /f' ); if (result.ok) { logLine('Hardware GPU Scheduling enabled - reboot required', true); return { ok: true, requiresReboot: true }; } return { ok: false, error: result.error }; } async function optimizeNVIDIA() { if (!isWindows()) return { ok: false }; const isAdmin = await checkIfAdmin(); if (!isAdmin) { return { ok: false, error: 'Requires administrator privileges' }; } try { const graphics = await si.graphics(); const hasNVIDIA = graphics.controllers.some(gpu => (gpu.vendor || '').toLowerCase().includes('nvidia') ); if (!hasNVIDIA) { return { ok: false, error: 'NVIDIA GPU not detected' }; } // Find actual GPU registry keys const { stdout } = await execAsync( 'reg query "HKLM\\SYSTEM\\CurrentControlSet\\Control\\Class\\{4d36e968-e325-11ce-bfc1-08002be10318}" /s /f "NVIDIA"', { timeout: 10000, windowsHide: true } ); // Extract subkey numbers (0000, 0001, etc.) const subkeys = []; const matches = stdout.matchAll(/\\(\d{4})$/gm); for (const match of matches) { subkeys.push(match[1]); } if (subkeys.length === 0) { return { ok: false, error: 'NVIDIA registry keys not found' }; } // Apply optimizations to each NVIDIA GPU const basePath = 'HKLM\\SYSTEM\\CurrentControlSet\\Control\\Class\\{4d36e968-e325-11ce-bfc1-08002be10318}'; for (const subkey of subkeys) { const commands = [ // Power management mode: Prefer maximum performance reg add "${basePath}\\${subkey}" /v PowerMizerEnable /t REG_DWORD /d 1 /f, reg add "${basePath}\\${subkey}" /v PowerMizerLevel /t REG_DWORD /d 1 /f, reg add "${basePath}\\${subkey}" /v PerfLevelSrc /t REG_DWORD /d 8738 /f, // Disable preemption reg add "${basePath}\\${subkey}" /v DisablePreemption /t REG_DWORD /d 1 /f, // Disable CUDA - Force P2 State reg add "${basePath}\\${subkey}" /v DisableCudaContextPreemption /t REG_DWORD /d 1 /f ]; for (const cmd of commands) { await safeExec(cmd); } logLine(Applied NVIDIA optimizations to GPU subkey: ${subkey}, true); } return { ok: true, gpuCount: subkeys.length, requiresReboot: true }; } catch (error) { logLine(NVIDIA optimization error: ${error.message}, true); return { ok: false, error: error.message }; } } async function optimizeStartupItems() { if (!isWindows()) return { ok: false }; try { // Get startup items const { stdout } = await execAsync( 'PowerShell.exe -ExecutionPolicy Bypass -Command "Get-CimInstance Win32_StartupCommand | Select-Object Name, Command, Location | ConvertTo-Json"', { timeout: 15000, windowsHide: true } ); let items = []; try { items = JSON.parse(stdout); if (!Array.isArray(items)) items = [items]; } catch { return { ok: false, error: 'Failed to parse startup items' }; } // Common bloat to disable const bloatPatterns = [ /steam/i, /discord/i, /spotify/i, /skype/i, /teams/i, /ccleaner/i, /adobe.*updater/i, /google.*update/i, /microsoft.*onedrive/i ]; let disabledCount = 0; for (const item of items) { const isBloat = bloatPatterns.some(pattern => pattern.test(item.Name) || pattern.test(item.Command) ); if (isBloat) { // Disable via registry const location = item.Location || ''; if (location.includes('Run')) { const regPath = location.replace('HKLM\\', 'HKLM\\').replace('HKCU\\', 'HKCU\\'); const cmd = reg delete "${regPath}" /v "${item.Name}" /f; const res = await safeExec(cmd); if (res.ok) disabledCount++; } } } return { ok: true, disabledCount, totalItems: items.length }; } catch (error) { return { ok: false, error: error.message }; } } // ==================== OPTIMIZATION MAIN HANDLER ==================== // Progress emitter function emitProgress(i, stepsLen, stepName) { const progress = Math.round((i / stepsLen) * 100); sendToRenderer('optimization-progress', { stepIndex: i, stepName, step: stepName, progress, totalSteps: stepsLen }); } // Main Optimization ipcMain.handle('perform-optimization', async (_e, options = {}) => { const earlyFail = (msg) => { sendToRenderer('optimization-complete', { ok: false, error: msg }); return { ok: false, error: msg }; }; if (!appState.isActivated) return earlyFail('License activation required'); if (!appState.isOptimizerEnabled) return earlyFail('Optimizer is disabled'); if (!isWindows()) return earlyFail('Windows-only optimization'); logLine('Starting system optimization'); const startTime = Date.now(); const memBefore = await si.mem(); const opts = { ...appState.options, ...options }; const steps = [ { key: 'gameMode', name: 'Enabling Game Mode', fn: enableGameMode }, { key: 'backgroundProcessTrim', name: 'Terminating background processes', fn: killBackgroundProcesses }, { key: 'diskCleanup', name: 'Cleaning temporary files', fn: cleanTempFiles }, { key: 'browserCacheCleanup', name: 'Clearing browser caches', fn: cleanBrowserCaches }, { key: 'recycleBinEmpty', name: 'Emptying Recycle Bin', fn: emptyRecycleBin }, { key: 'windowsUpdateCacheCleanup', name: 'Cleaning Windows Update cache', fn: cleanWindowsUpdateCache }, { key: 'logsCleanup', name: 'Cleaning system logs', fn: cleanSystemLogs }, { key: 'memoryCompression', name: 'Optimizing memory', fn: optimizeMemory }, { key: 'storageOptimize', name: 'Optimizing storage', fn: optimizeStorage }, { key: 'dnsSwitch', name: 'Optimizing DNS settings', fn: optimizeDNS }, { key: 'tcpTune', name: 'Optimizing TCP settings', fn: optimizeTCP }, { key: 'gpuVisualTuning', name: 'Optimizing visual effects', fn: optimizeVisualEffects }, { key: 'hardwareGpuScheduling', name: 'Enabling GPU hardware scheduling', fn: enableHardwareGPUScheduling }, { key: 'nvapi', name: 'Optimizing NVIDIA settings', fn: optimizeNVIDIA }, { key: 'startupItems', name: 'Optimizing startup items', fn: optimizeStartupItems } ]; const results = []; let totalJunkCleaned = 0; for (let i = 0; i < steps.length; i++) { const step = steps[i]; if (!opts[step.key]) { results.push({ key: step.key, name: step.name, skipped: true, ok: true, durationMs: 0 }); emitProgress(i + 1, steps.length, ${step.name} (skipped)); continue; } // Emit starting emitProgress(i, steps.length, Starting: ${step.name}); const t0 = Date.now(); let outcome; try { outcome = await step.fn(); } catch (e) { outcome = { ok: false, error: e.message || 'Unknown error' }; } const durationMs = Date.now() - t0; if (outcome && typeof outcome.cleanedGB === 'number') { totalJunkCleaned += outcome.cleanedGB; } results.push({ key: step.key, name: step.name, ok: !!outcome?.ok, error: outcome?.error || null, extra: outcome, durationMs }); // Emit completion const status = outcome?.ok ? '✓' : '✗'; emitProgress(i + 1, steps.length, ${status} ${step.name}); } // RAM delta const memAfter = await si.mem(); const beforeBytes = (memBefore.active || memBefore.used || 0); const afterBytes = (memAfter.active || memAfter.used || 0); const ramFreedGB = bytesToGB(Math.max(0, beforeBytes - afterBytes)); appState.lastOptimization = new Date().toISOString(); appState.lastRamFreedGB = parseFloat(ramFreedGB.toFixed(2)); appState.lastJunkCleanedGB = parseFloat(totalJunkCleaned.toFixed(2)); await saveSettings(); // Report ensurePaths(); const hwid = await getStableHWID(); const report = { timestamp: appState.lastOptimization, hwid, optionsUsed: opts, results, summary: { durationMs: Date.now() - startTime, ramFreedGB: appState.lastRamFreedGB, junkCleanedGB: appState.lastJunkCleanedGB }, versions: { app: app.getVersion(), electron: process.versions.electron, node: process.versions.node } }; try { await fs.writeFile(REPORT_PATH, JSON.stringify(report, null, 2), 'utf-8'); } catch (e) { logLine(Failed to write report: ${e.message}, true); } logLine(Optimization complete. RAM freed: ${appState.lastRamFreedGB} GB, Junk cleaned: ${appState.lastJunkCleanedGB} GB); sendToRenderer('optimization-complete', { ok: true, summary: report.summary, results }); return { ok: true, summary: report.summary, results }; }); // ==================== FEATURE TESTING ==================== ipcMain.handle('test-optimization-feature', async (_e, key) => { const map = { gameMode: enableGameMode, backgroundProcessTrim: killBackgroundProcesses, diskCleanup: cleanTempFiles, browserCacheCleanup: cleanBrowserCaches, recycleBinEmpty: emptyRecycleBin, windowsUpdateCacheCleanup: cleanWindowsUpdateCache, logsCleanup: cleanSystemLogs, memoryOptimization: optimizeMemory, networkOptimization: async () => { const a = await optimizeDNS(); const b = await optimizeTCP(); return { ok: a.ok && b.ok }; }, visualEffects: optimizeVisualEffects, gpuScheduling: enableHardwareGPUScheduling, nvapi: optimizeNVIDIA, startupItems: optimizeStartupItems }; const fn = map[key]; if (!fn) return { ok: false, error: Unknown feature: ${key} }; try { const res = await fn(); return { ok: !!res?.ok, result: res }; } catch (e) { return { ok: false, error: e.message || 'Unknown error' }; } }); // ==================== HEALTH CHECK ==================== ipcMain.handle('run-system-health-check', async () => { if (!isWindows()) return { ok: false, error: 'Windows-only operation' }; try { const [mem, load, fsSize, osInfo] = await Promise.all([ si.mem(), si.currentLoad(), si.fsSize(), si.osInfo() ]); const totalGB = bytesToGB(mem.total); const usedGB = bytesToGB(mem.active || mem.used); const freeGB = Math.max(0, totalGB - usedGB); const cpuLoad = load.currentload || 0; const diskC = fsSize.find(d => (d.mount || '').toUpperCase() === 'C:'); const diskFreePct = diskC ? (100 - (diskC.use || 0)) : 0; let latencyMs = null; try { const { stdout } = await execAsync('ping -n 1 8.8.8.8', { timeout: 5000, windowsHide: true }); // Multi-language support const patterns = [ /Average = (\d+)ms/i, /Moyenne\s?=\s?(\d+)\s?ms/i, /Mittelwert\s?=\s?(\d+)\s?ms/i, /Media\s?=\s?(\d+)\s?ms/i, /平均\s?=\s?(\d+)\s?ms/i, /time=(\d+)ms/i, /時間=(\d+)ms/i ]; for (const pattern of patterns) { const match = stdout.match(pattern); if (match) { latencyMs = parseInt(match[1], 10); break; } } if (latencyMs === null) { const fallback = stdout.match(/(\d+)\s?ms/i); if (fallback) latencyMs = parseInt(fallback[1], 10); } } catch { /* ignore */ } let score = 100; if (cpuLoad > 85) score -= 20; if (freeGB < 2) score -= 20; if (diskFreePct < 10) score -= 15; if (latencyMs !== null) { if (latencyMs > 100) score -= 15; else if (latencyMs > 60) score -= 8; } score = Math.max(0, Math.min(100, Math.round(score))); return { ok: true, score, details: { os: ${osInfo.distro} ${osInfo.release}, cpuLoadPct: Math.round(cpuLoad), ram: { totalGB: totalGB.toFixed(2), usedGB: usedGB.toFixed(2), freeGB: freeGB.toFixed(2) }, diskC: diskC ? { sizeGB: bytesToGB(diskC.size).toFixed(2), usedPct: diskC.use, freePct: (100 - diskC.use).toFixed(2) } : null, latencyMs } }; } catch (e) { return { ok: false, error: e.message || 'Health check failed' }; } }); // ==================== PERFORMANCE METRICS ==================== ipcMain.handle('get-performance-metrics', async () => { try { const [load, mem] = await Promise.all([si.currentLoad(), si.mem()]); return { ok: true, metrics: { cpuLoadPct: Math.round(load.currentload || 0), memUsedGB: (mem.active ? mem.active : mem.used) / (1024 ** 3), memTotalGB: mem.total / (1024 ** 3), appHeapMB: Math.round(process.memoryUsage().heapUsed / 1024 / 1024) } }; } catch (e) { return { ok: false, error: e.message || 'Failed to read metrics' }; } }); // ==================== RESTORE POINTS ==================== ipcMain.handle('create-restore-point', async (_e, description = 'Aura Restore Point') => { if (!isWindows()) return { ok: false, error: 'Windows-only operation' }; const isAdmin = await checkIfAdmin(); if (!isAdmin) { return { ok: false, error: 'Requires administrator privileges' }; } try { // Check if System Restore is enabled const checkCmd = 'PowerShell.exe -Command "Get-ComputerRestorePoint -ErrorAction SilentlyContinue | Measure-Object | Select-Object -ExpandProperty Count"'; const checkResult = await safeExec(checkCmd, { timeout: 10000 }); if (!checkResult.ok) { return { ok: false, error: 'System Restore may not be enabled' }; } // Create restore point asynchronously const sanitizedDesc = String(description).replace(/['"]/g, ''); const cmd = PowerShell.exe -ExecutionPolicy Bypass -Command "Start-Job -ScriptBlock { Checkpoint-Computer -Description '${sanitizedDesc}' -RestorePointType 'MODIFY_SETTINGS' }"; const res = await safeExec(cmd, { timeout: 10000 }); if (!res.ok) { throw new Error(res.error || 'Failed to start restore point creation'); } // App ledger ensurePaths(); let ledger = []; try { ledger = JSON.parse(await fs.readFile(RESTORE_POINTS_PATH, 'utf-8')); } catch { /* ignore */ } ledger.push({ description: sanitizedDesc, createdAt: new Date().toISOString() }); await fs.writeFile(RESTORE_POINTS_PATH, JSON.stringify(ledger, null, 2)); logLine('Restore point creation started in background', true); return { ok: true, message: 'Restore point creation started (may take several minutes)' }; } catch (e) { logLine(Restore point error: ${e.message}, true); return { ok: false, error: e.message }; } }); ipcMain.handle('get-restore-points', async () => { if (!isWindows()) return { ok: false, error: 'Windows-only operation' }; try { const { stdout } = await execAsync( 'PowerShell.exe -Command "Get-ComputerRestorePoint | ConvertTo-Json -Depth 3"', { timeout: 15000, windowsHide: true } ); let points = []; try { points = JSON.parse(stdout || '[]'); } catch { points = []; } if (!Array.isArray(points)) points = [points]; const normalized = points.map(p => ({ id: p.SequenceNumber, description: p.Description, createdAt: p.CreationTime || p.CreationTimeUTC || null, size: 0 })); return { ok: true, restorePoints: normalized }; } catch (e) { return { ok: false, error: e.message || 'Failed to list restore points' }; } }); ipcMain.handle('restore-from-point', async (_e, pointId) => { if (!isWindows()) return { ok: false, error: 'Windows-only operation' }; const idNum = parseInt(pointId, 10); if (!Number.isFinite(idNum)) return { ok: false, error: 'Invalid restore point id' }; try { const cmd = PowerShell.exe -Command "Restore-Computer -RestorePoint ${idNum}"; const r = await safeExec(cmd, { timeout: 120000 }); if (!r.ok) throw new Error(r.error || 'Restore command failed'); return { ok: true, message: 'System Restore triggered. A reboot may be required.' }; } catch (e) { return { ok: false, error: e.message || 'Failed to restore' }; } }); // ==================== LOGS ==================== ipcMain.handle('get-debug-logs', async () => { ensurePaths(); try { const main = fsSync.existsSync(LOG_PATH) ? fsSync.readFileSync(LOG_PATH, 'utf-8') : ''; const debug = fsSync.existsSync(DEBUG_LOG_PATH) ? fsSync.readFileSync(DEBUG_LOG_PATH, 'utf-8') : ''; return { ok: true, logs: { main, debug } }; } catch (e) { return { ok: false, error: e.message || 'Failed to clear logs' }; } }); // Export logs ipcMain.handle('export-logs', async () => { ensurePaths(); try { const result = await dialog.showSaveDialog(appState.window, { title: 'Export Logs', defaultPath: aura-logs-${new Date().toISOString().split('T')[0]}.txt, filters: [{ name: 'Text Files', extensions: ['txt'] }] }); if (result.canceled || !result.filePath) { return { ok: false, error: 'Export cancelled' }; } const main = fsSync.existsSync(LOG_PATH) ? fsSync.readFileSync(LOG_PATH, 'utf-8') : ''; const debug = fsSync.existsSync(DEBUG_LOG_PATH) ? fsSync.readFileSync(DEBUG_LOG_PATH, 'utf-8') : ''; const combined = === AURA GAMING PC OPTIMIZER - LOG EXPORT === Export Date: ${new Date().toISOString()} App Version: ${app.getVersion()} ...; await fs.writeFile(result.filePath, combined, 'utf-8'); return { ok: true, path: result.filePath }; } catch (e) { return { ok: false, error: e.message || 'Failed to export logs' }; } }); // Open external links ipcMain.handle('open-external', async (_e, url) => { try { await shell.openExternal(url); return { ok: true }; } catch (e) { return { ok: false, error: e.message || 'Failed to open URL' }; } }); // Get comprehensive app info ipcMain.handle('get-app-info', async () => { try { const osInfo = await si.osInfo(); const cpu = await si.cpu(); const mem = await si.mem(); const graphics = await si.graphics(); return { ok: true, info: { appVersion: app.getVersion(), electronVersion: process.versions.electron, nodeVersion: process.versions.node, platform: process.platform, arch: process.arch, os: ${osInfo.distro} ${osInfo.release} (Build ${osInfo.build}), cpu: cpu.brand, ram: ${bytesToGB(mem.total).toFixed(2)} GB, gpu: graphics.controllers.map(g => g.model).join(', ') || 'Unknown', isAdmin: await checkIfAdmin() } }; } catch (e) { return { ok: false, error: e.message || 'Failed to get app info' }; } });